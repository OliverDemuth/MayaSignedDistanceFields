/* ligLength.mel

    This script calculates the shortest path (length) of a ligament from origin to
    insertion wrapping around the proximal and distal bone meshes. It generates an
    on-the-fly visibility graph embedded in an A* search algorithm to find the 
    shortest distance. 

    Written by Oliver Demuth 19.04.2022
    Last updated 04.05.2022 - Oliver Demuth

    SYNOPSIS:

        INPUT params:
            string  $origin:        Name of the origin point, i.e. the name of a locator at the position of the ligament origin
            string  $insertion:     Name of the insertion point, i.e. the name of a locator at the position of the ligament insertion
            string  $jointcentre:   Name of the joint centre, i.e. the name of a locator or joint, e.g. "myJoint" if following the ROM mapping protocol of Manafzadeh & Padian 2018
            string  $proximal:          Name of the proximal bone mesh, e.g. the meshes that were used for the boolean if following the ROM mapping protocol of Manafzadeh & Padian 2018
            string  $distal:          Name of the distal bone mesh, e.g. the meshes that were used for the boolean if following the ROM mapping protocol of Manafzadeh & Padian 2018
            int     $res:           Integer value to define the resolution of the curve approximating the slices.

        RETURN params:
            float   $PathLength[]:  Return value is a float array with two elements in the form of:

            element 0: 
                0   | False:    failure, no shortest path (end point cannot be reached from start point through Pointset and NeighborSet): {0.0,-1.0}
                1   | True:     shortest path found: {1.0,..}

            element 1:
                $Length:        Length of path from starting point to end point

    Note, the accuracy of the reported length depends on the resolution of the curve 
    approximating the slices through the bone meshes. The lower the resolution '$res', 
    the faster the script runs; however, accuracy is also reduced. 
    
*/


/*===================================================/

    Helper procedure:
    
    The global proc 'intersect' checks if two lines $s1 and $s2 defined by four points
    ($p0, $p1, $p2 & $p3) intersect each other in the two dimensional plane ($u,$v)
    defined by $origin, $insertion and the joint centre

        where 
            $u = value along the axis from $origin to $insertion
        and
            $v = value on the axis perpendicular to the first axis and the normal of the plane

/===================================================*/


global proc int intersect(string  $p0, string $p1, string $p2, string $p3)
{
    // get $u and $t variables stored in scaleX and scaleY, i.e. scaleX = U,  scaleY = V

    vector $p0Pos = `getAttr ($p0 + ".scale")`; 
    vector $p1Pos = `getAttr ($p1 + ".scale")`; 
    vector $p2Pos = `getAttr ($p2 + ".scale")`;
    vector $p3Pos = `getAttr ($p3 + ".scale")`;

    float $s1x = $p1Pos.x - $p0Pos.x;
    float $s1y = $p1Pos.y - $p0Pos.y;
    float $s2x = $p3Pos.x - $p2Pos.x;
    float $s2y = $p3Pos.y - $p2Pos.y;
    
    int $intersection;
    
    if ((-$s2x * $s1y + $s1x * $s2y) == 0) // line segments are parallel
    {
        $intersection = -1;
        return $intersection;
    }
    else // line segments are not parallel
    {
        float $v = (-$s1y * ($p0Pos.x - $p2Pos.x) + $s1x * ($p0Pos.y - $p2Pos.y)) / (-$s2x * $s1y + $s1x * $s2y);
        float $w = ($s2x * ($p0Pos.y - $p2Pos.y) - $s2y * ($p0Pos.x - $p2Pos.x)) / (-$s2x * $s1y + $s1x * $s2y);
    
        if($v > 0 && $v < 1 && $w > 0 && $w < 1) // segments intersect
        {
            $intersection = 1;
        }
        else // they don't intersect
        {
            $intersection = 0;
        }
        
        return $intersection;
    }
}


/*===================================================/

    Main procedure: 

    Ligament length calculations incorporating A* search algorithm and on-the-fly 
    brute force visibility graph for the active points at O((n-1)*E), worst case 
    overall runtime O(n^3)


/===================================================*/


global proc float[] ligLength(string  $origin, string $insertion, string $jointcentre, string $proximal, string $distal, int $res)
{
    // data house keeping

    string $proxT[];
    tokenize $proximal "|" $proxT;
    int $sizeProxBuff = size($proxT);
    string $nProxClean = $proxT[$sizeProxBuff-1];
    string $nProxCopy = $nProxClean + "_duplicate";
    string $prox = "ProxBoneMesh";
    duplicate -n $nProxCopy $proximal;
    rename $proximal $prox;

    string $distT[];
    tokenize $distal "|" $distT;
    int $sizeDistBuff = size($distT);
    string $nDistClean = $distT[$sizeDistBuff-1];
    string $nDistCopy = $nDistClean + "_duplicate";
    string $dist = "DistBoneMesh";
    duplicate -n $nDistCopy $distal;
    rename $distal $dist;



    //==================== Initial calculations based on input data ====================//

    // get positions of points of interest

    vector $oPos = `xform -q -t -ws $origin`;
    vector $iPos = `xform -q -t -ws $insertion`;
    vector $jPos = `xform -q -t -ws $jointcentre`;

    // calculate vector from origin to insertion

    vector $LigDir = $oPos - $iPos;
    vector $JointDir = $oPos - $jPos;
    float $Offset = mag($LigDir);

    // calculate cut plane direction

    vector $uCross = unit(cross ($LigDir, $JointDir));
    vector $vCross = unit(cross ($LigDir, $uCross));
    vector $cutAim = `angleBetween -euler -v1 0 0 1 -v2 ($uCross.x) ($uCross.y) ($uCross.z)`;

    // normalise vectors

    vector $LigDirNorm = (unit($LigDir))/$Offset;
    vector $vCrossNorm = $vCross/$Offset;

    // get number of faces 

    int $numProxFace[] = `polyEvaluate -f $prox`;
    int $numProxF = $numProxFace[0] - 1;
    string $proxF = (string)$prox + ".f[0:" + $numProxF + "]";

    int $numDistFace[] = `polyEvaluate -f $dist`;
    int $numDistF = $numDistFace[0] - 1;
    string $distF = (string)$dist + ".f[0:" + $numDistF + "]";



    //============ slice proximal and distal meshes to get collision points ============//

    // cut proximal mesh
        
    polyCut 
            -pc ($jPos.x) ($jPos.y) ($jPos.z)
            -ro ($cutAim.x) ($cutAim.y) ($cutAim.z)
            -ps 2 2
            -ef 1
            -eo 0 0 0
            $proxF;

    // get numbers of newly created faces, i.e. the faces describing the slices 

    int $numProxPreSlice[] = `polyEvaluate -f $prox`;
      
    select $prox;
    polyCloseBorder;

    int $numProxPostSlice[] = `polyEvaluate -f $prox`; 
    int $proxFaceDiff = ($numProxPostSlice[0] - $numProxPreSlice[0])/2; // get number of new faces

    select -clear;

    // cut distal mesh
        
    polyCut 
            -pc ($jPos.x) ($jPos.y) ($jPos.z)
            -ro ($cutAim.x) ($cutAim.y) ($cutAim.z)
            -ps 2 2
            -ef 1
            -eo 0 0 0
            $distF;

    // get numbers of newly created faces, i.e. the faces describing the slices 

    int $numDistPreSlice[] = `polyEvaluate -f $dist`;
      
    select $dist;
    polyCloseBorder;

    int $numDistPostSlice[] = `polyEvaluate -f $dist`; 
    int $distFaceDiff = ($numDistPostSlice[0] - $numDistPreSlice[0])/2; // get number of new faces

    select -clear;

    // define temporary variables to get edges and vertices of meshes

    string $proxNewFaces[];
    string $distNewFaces[];
    string $tempFaces[];
    string $TempVtcs[];
    string $TempEdges[];
    string $TempSliceEdges[];
    string $Vtcs[];
    string $ProxEdges[];
    string $DistEdges[];
    string $AllEdges[];
    string $AllProxEdges[];
    string $AllDistEdges[];
    
    string $VtxArray[];
    string $ProxEdgeArray[];
    string $DistEdgeArray[];

    // define temporary group to store locators, curves and planes

    string $tempGRP = "TempGRP";
    group -em -n $tempGRP;

    

    //=================== get edges of proximal mesh slice ===================//

    for ($i = 0;$i<$proxFaceDiff;$i++) 
    {
        $proxNewFaces[$i] = (string)$prox + ".f[" + ($numProxPostSlice[0]-$i-1) + "]";
        string $tempCRV = $prox + "_CRV_" + $i;
        string $tempPlane = $prox + "_plane_" + $i;
           
        $TempSliceEdges = `polyListComponentConversion -ff -te $proxNewFaces[$i]`;

        // triangulate slice
       
        select $proxNewFaces[$i];
        polyTriangulate $proxNewFaces[$i];  
    
        // get vertex and face IDs from triangulated slice
    
        string $vertIndicesStr[] = `polyInfo -fv`;
        int $sliceFaceNum = `size($vertIndicesStr)`;    
    
        // calculate area of the slice
    
        string $vertIndices[];
        float $s;
        float $FaceArea[];
        float $FacetotArea = 0;
            
        for ($l = 0;$l<$sliceFaceNum;$l++) // get position of each triangle vertex
        {
            tokenizeList($vertIndicesStr[$l], $vertIndices);
       
            string $VtxA = (string)$prox + ".vtx[" + $vertIndices[2] + "]";
            string $VtxB = (string)$prox + ".vtx[" + $vertIndices[3] + "]";
            string $VtxC = (string)$prox + ".vtx[" + $vertIndices[4] + "]";
            
            // querry position of each vertex and calculate distances between them
            
            vector $VtxAPos = `xform -q -t -ws $VtxA`;
            vector $VtxBPos = `xform -q -t -ws $VtxB`;
            vector $VtxCPos = `xform -q -t -ws $VtxC`;
            
            float $DistA = mag ($VtxBPos-$VtxCPos);
            float $DistB = mag ($VtxAPos-$VtxCPos);
            float $DistC = mag ($VtxAPos-$VtxBPos);
            
            //calculate area and center position of each triangle
            
            $s = ($DistA + $DistB + $DistC)/2;
            $FaceArea[$l] = sqrt($s * ($s-$DistA) * ($s-$DistB) * ($s-$DistC));
            $FacetotArea += $FaceArea[$l];
        }

        // translate slice area into curve resolution circumscribing slice
        
        float $log = `log ($FacetotArea)`;
        int $resolution = ceil($res + ($res * $log));
        if ($resolution < 4)
        {
            $resolution = 4;
        }

        // approximate slice surface and reduce number of vertices and edges to a more reasonable number based on slice area

        select $TempSliceEdges;
        polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 0 -n $tempCRV;
        select -clear;
        
        // rebuild curve and approximate slice
        
        rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 1 -s $resolution -d 1 -tol 1e-08 $tempCRV;
        nurbsToPolygonsPref -pt 1 -pc 1;
        planarSrf -ch 1 -d 1 -ko 0 -tol 1e-01 -rn 0 -po 1 -n $tempPlane $tempCRV;
        
        parent $tempCRV $tempGRP;
        parent $tempPlane $tempGRP;
        
        // get vertices and edges from new slice
        
        string $tempPlaneF = $tempPlane + ".f[0]";
        
        $TempVtcs = `polyListComponentConversion -ff -tv $tempPlaneF`;
        $Vtcs = stringArrayCatenate ($Vtcs, $TempVtcs);
        
        $TempEdges = `polyListComponentConversion -ff -te $tempPlaneF`;
        $ProxEdges = stringArrayCatenate ($ProxEdges, $TempEdges);
        
        select $tempPlaneF;
        polyTriangulate -ch 1 $tempPlaneF;
        $tempFaces = `ls -sl`;
        select -clear;
        
        $TempAllEdges = `polyListComponentConversion -ff -te $tempFaces`;
        $AllProxEdges = stringArrayCatenate ($AllProxEdges, $TempAllEdges);
    }



    //=================== get edges of distal mesh slice ===================//

    for ($i = 0;$i<$distFaceDiff;$i++) 
    {
        $distNewFaces[$i] = (string)$dist + ".f[" + ($numDistPostSlice[0]-$i-1) + "]";
        string $tempCRV = $dist + "_CRV_" + $i;
        string $tempPlane = $dist + "_plane_" + $i;
        
        $TempSliceEdges = `polyListComponentConversion -ff -te $distNewFaces[$i]`;

        // triangulate slice
        
        select $distNewFaces[$i];
        polyTriangulate $distNewFaces[$i];  
    
        // get vertex and face IDs from triangulated slice
    
        string $vertIndicesStr[] = `polyInfo -fv`;
        int $sliceFaceNum = `size($vertIndicesStr)`;
        
        select -clear;  
    
        // calculate area of the slice
    
        string $vertIndices[];
        float $s;
        float $FaceArea[];
        float $FacetotArea = 0;
            
        for ($l = 0;$l<$sliceFaceNum;$l++) // get position of each triangle vertex
        {
            tokenizeList($vertIndicesStr[$l], $vertIndices);
       
            string $VtxA = (string)$dist + ".vtx[" + $vertIndices[2] + "]";
            string $VtxB = (string)$dist + ".vtx[" + $vertIndices[3] + "]";
            string $VtxC = (string)$dist + ".vtx[" + $vertIndices[4] + "]";
            
            // querry position of each vertex and calculate distances between them
            
            vector $VtxAPos = `xform -q -t -ws $VtxA`;
            vector $VtxBPos = `xform -q -t -ws $VtxB`;
            vector $VtxCPos = `xform -q -t -ws $VtxC`;
            
            float $DistA = mag ($VtxBPos-$VtxCPos);
            float $DistB = mag ($VtxAPos-$VtxCPos);
            float $DistC = mag ($VtxAPos-$VtxBPos);
            
            //calculate area and center position of each triangle
            
            $s = ($DistA + $DistB + $DistC)/2;
            $FaceArea[$l] = sqrt($s * ($s-$DistA) * ($s-$DistB) * ($s-$DistC));
            $FacetotArea += $FaceArea[$l];
        }

        // translate slice area into curve resolution circumscribing slice
        
        float $log = `log ($FacetotArea)`;
        int $resolution = ceil($res + ($res*$log));
        if ($resolution < 4)
        {
            $resolution = 4;
        }

        // approximate slice surface and reduce number of vertices and edges to a more reasonable number based on slice area
        
        select $TempSliceEdges;
        polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 0 -n $tempCRV;
        select -clear;
        
        // rebuild curve and approximate slice
        
        rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 1 -s $resolution -d 1 -tol 1e-08 $tempCRV;
        nurbsToPolygonsPref -pt 1 -pc 1;
        planarSrf -ch 1 -d 1 -ko 0 -tol 1e-01 -rn 0 -po 1 -n $tempPlane $tempCRV;
        
        parent $tempCRV $tempGRP;
        parent $tempPlane $tempGRP;
        
        // get vertices and edges from new slice
        
        string $tempPlaneF = $tempPlane + ".f[0]";
        
        $TempVtcs = `polyListComponentConversion -ff -tv $tempPlaneF`;
        $Vtcs = stringArrayCatenate ($Vtcs, $TempVtcs);
        
        $TempEdges = `polyListComponentConversion -ff -te $tempPlaneF`;
        $DistEdges = stringArrayCatenate ($DistEdges, $TempEdges);
        
        select $tempPlaneF;
        polyTriangulate -ch 1 $tempPlaneF;
        $tempFaces = `ls -sl`;
        select -clear;
        
        $TempAllEdges = `polyListComponentConversion -ff -te $tempFaces`;
        $AllDistEdges = stringArrayCatenate ($AllDistEdges, $TempAllEdges);
    }

    // expand edge and vertex arrays to get individual indices

    $VtxArray = `filterExpand -sm 31 $Vtcs`;
    int $sizeVtxArray = `size $VtxArray`;

    $ProxEdgeArray = `filterExpand -sm 32 $ProxEdges`;
    $DistEdgeArray = `filterExpand -sm 32 $DistEdges`;

    int $sizeProxEdgeArray = `size $ProxEdgeArray`;
    int $sizeDistEdgeArray = `size $DistEdgeArray`;

    $AllProxEdgeArray = `filterExpand -sm 32 $AllProxEdges`;
    $AllDistEdgeArray = `filterExpand -sm 32 $AllDistEdges`;

    int $sizeAllProxEdgeArray = `size $AllProxEdgeArray`;
    int $sizeAllDistEdgeArray = `size $AllDistEdgeArray`;

        

    //============== create locators and store attributes from vertices ==============//

    // define temporary variables to translate vertices and edges into locators

    string $tempLoc[];
    string $nTempLoc;
    string $pad[];
    string $VtxT1[];
    string $VtxT2[];
    string $VtxT3[];
    string $TempVtx[];

    string $EdgeSet[];
    string $ProxEdgeSet[];
    string $DistEdgeSet[];

    string $AllEdgeSet[];
    string $AllProxEdgeSet[];
    string $AllDistEdgeSet[];

    string $VtxSet[];

    vector $tempPos;
    vector $tempUV;
    vector $pOffset;
    float $u;
    float $v;
    int $sizeTempVec;

    // get vertex set and define locators
    
    for ($k = 0;$k<$sizeVtxArray;$k++)
    {
        // extract vertex index and get name for locator

        $VtxT3 = stringToStringArray($VtxArray[$k], ".[]");
        $pad[3] = `python ("'%05d' % "+$VtxT3[2])`;
        $nTempLoc = $VtxT3[0] + "_VtxLoc_" + $pad[3];
        $VtxSet[$k] = $nTempLoc;

        // calculate U and V values of plane defined by origin, insertion and joint centre

        $tempPos = `xform -q -t -ws $VtxArray[$k]`;
        $pOffset = $oPos - $tempPos;
        $u = dot ($pOffset, $LigDirNorm);
        $v = dot ($pOffset, $vCrossNorm);
        $tempUV = <<$u, $v, 1>>;

        // create temporary locator at position vertex position and set U and V values

        spaceLocator -p 0 0 0 -n $nTempLoc;
        setAttr ($nTempLoc + ".translate") ($tempPos.x) ($tempPos.y) ($tempPos.z);
        setAttr ($nTempLoc + ".scale") ($tempUV.x) ($tempUV.y) ($tempUV.z);
        parent $nTempLoc $tempGRP;
    }

    // get all edges cicrumscribing the polygons

    // proximal mesh

    for ($j = 0;$j<$sizeProxEdgeArray;$j++)  
    {
        $TempVtcs = `polyListComponentConversion -fe -tv $ProxEdgeArray[$j]`;
        $sizeTempVec = `size $TempVtcs`;

        if ($sizeTempVec == 1) // if vertices are adjacent expand them to get individual vertex indices, i.e. [N:N+1] -> [N] & [N+1]
        {
            $TempVtx = `filterExpand -sm 31 $TempVtcs[0]`;
            $VtxT1 = stringToStringArray($TempVtx[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtx[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0]+ "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $ProxEdgeSet[$j] = ($tempLoc[0] + " " + $tempLoc[1]); 
        }
        else // vertices are not adjacent, extract indices directly
        {
            $VtxT1 = stringToStringArray($TempVtcs[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtcs[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0] + "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $ProxEdgeSet[$j] = ($tempLoc[0] + " " + $tempLoc[1]);
        }
    }

    // distal mmesh

    for ($j = 0;$j<$sizeDistEdgeArray;$j++) 
    {
        $TempVtcs = `polyListComponentConversion -fe -tv $DistEdgeArray[$j]`;
        $sizeTempVec = `size $TempVtcs`;

        if ($sizeTempVec == 1) // if vertices are adjacent expand them to get individual vertex indices, i.e. [N:N+1] -> [N] & [N+1]
        {
            $TempVtx = `filterExpand -sm 31 $TempVtcs[0]`;
            $VtxT1 = stringToStringArray($TempVtx[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtx[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0]+ "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $DistEdgeSet[$j] = ($tempLoc[0] + " " + $tempLoc[1]); 
        }
        else // vertices are not adjacent, extract indices directly
        {
            $VtxT1 = stringToStringArray($TempVtcs[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtcs[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0] + "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $DistEdgeSet[$j] = ($tempLoc[0] + " " + $tempLoc[1]);
        }
    }

    // combine proximal and distal edge sets to get all edges circumscribing the polygons

    $EdgeSet = stringArrayCatenate ($ProxEdgeSet, $DistEdgeSet); // combine proximal and distal edges

    // get all edges within and circumscribing the polygons

    // proximal mesh

    for ($l = 0;$l<$sizeAllProxEdgeArray;$l++) 
    {
        $TempVtcs = `polyListComponentConversion -fe -tv $AllProxEdgeArray[$l]`;
        $sizeTempVec = `size $TempVtcs`;

        if ($sizeTempVec == 1) // if vertices are adjacent expand them to get individual vertex indices, i.e. [N:N+1] -> [N] & [N+1]
        {
            $TempVtx = `filterExpand -sm 31 $TempVtcs[0]`;
            $VtxT1 = stringToStringArray($TempVtx[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtx[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0]+ "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $AllProxEdgeSet[$l] = ($tempLoc[0] + " " + $tempLoc[1]); 
        }
        else // vertices are not adjacent, extract indices directly
        {
            $VtxT1 = stringToStringArray($TempVtcs[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtcs[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0] + "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $AllProxEdgeSet[$l] = ($tempLoc[0] + " " + $tempLoc[1]);
        }
    }

    // distal mesh

    for ($l = 0;$l<$sizeAllDistEdgeArray;$l++) 
    {
        $TempVtcs = `polyListComponentConversion -fe -tv $AllDistEdgeArray[$l]`;
        $sizeTempVec = `size $TempVtcs`;

        if ($sizeTempVec == 1) // if vertices are adjacent expand them to get individual vertex indices, i.e. [N:N+1] -> [N] & [N+1]
        {
            $TempVtx = `filterExpand -sm 31 $TempVtcs[0]`;
            $VtxT1 = stringToStringArray($TempVtx[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtx[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0]+ "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $AllDistEdgeSet[$l] = ($tempLoc[0] + " " + $tempLoc[1]); 
        }
        else // vertices are not adjacent, extract indices directly
        {
            $VtxT1 = stringToStringArray($TempVtcs[0], ".[]");
            $VtxT2 = stringToStringArray($TempVtcs[1], ".[]");
            $pad[0] = `python ("'%05d' % "+$VtxT1[2])`;
            $pad[1] = `python ("'%05d' % "+$VtxT2[2])`;
            $tempLoc[0] = $VtxT1[0] + "_VtxLoc_" + $pad[0];
            $tempLoc[1] = $VtxT1[0] + "_VtxLoc_" + $pad[1];
            
            $AllDistEdgeSet[$l] = ($tempLoc[0] + " " + $tempLoc[1]);
        }
    }

    // combine proximal and distal edge sets to get all edges

    $AllEdgeSet = stringArrayCatenate ($AllProxEdgeSet, $AllDistEdgeSet);

    // get edges crossing the polygon (i.e. only triangulation edges)

    string $AllEdgeCrossSet[] = stringArrayRemove($EdgeSet, $AllEdgeSet);
    string $ProxEdgeCrossSet[] = stringArrayRemove($ProxEdgeSet, $AllProxEdgeSet);
    string $DistEdgeCrossSet[] = stringArrayRemove($DistEdgeSet, $AllDistEdgeSet);

    // add origin and insertion to $VtxSet and set their U and V values

    $VtxSet[$sizeVtxArray] = $origin;
    $VtxSet[($sizeVtxArray+1)] = $insertion;
    setAttr ($origin + ".scale") 0 0 1;
    setAttr ($insertion + ".scale") 1 0 1;



    //============= calculate ligament length using the A* search algorithm =============//

    // definitions

    string $OpenSet[];
    string $ClosedSet[];
    string $PointSet2[];

    string $TemporaryVtx[];
    string $Previous[];
    string $Path[];
    string $visGraph[];
    string $Neighbors;
    
    string $RefEdgeSet[];
    string $RefCrossSet[];

    // add starting point to $OpenSet;

    int $size = `size $OpenSet`;
    $OpenSet[$size] = $origin;

    int $OpenSetSize = `size $OpenSet`;

    // move from start point through PointSet until end point reached or all points are exhausted

    while ($OpenSetSize > 0)
    {
        int $lowestIndex = 0;
        for ($i = 0; $i < $OpenSetSize; $i++)
        {
            float $OpenSetFI = `getAttr ($OpenSet[$i] + ".rotateX")`;
            float $OpenSetFLowest = `getAttr ($OpenSet[$lowestIndex] + ".rotateX")`;

            if ($OpenSetFI < $OpenSetFLowest) // check for smallest f value
            {
                $lowestIndex = $i;
            } 
        }

        // get current

        string $current = $OpenSet[$lowestIndex];

        if ($current == $insertion) // if end point is reached we are done!
        {
            float $Length = float(`getAttr ($current + ".rotateY")`);
            float $PathLength[];
            $PathLength = {1.0,$Length};

            // clean up

            delete $prox $dist $tempGRP;
            rename $nDistCopy $distal;
            rename $nProxCopy $proximal;
            
            setAttr ($origin + ".scale") 1 1 1;
            setAttr ($insertion + ".scale") 1 1 1;
            setAttr ($insertion + ".rotate") 0 0 0;

            // report ligament length

            return $PathLength;
        }

        // remove current from OpenSet

        string $remove[];
        $remove[0] = $current;
        $OpenSet = stringArrayRemove($remove, $OpenSet);

        // add $current to $ClosedSet

        int $ClosedSetSize = `size($ClosedSet)`;
        $ClosedSet[$ClosedSetSize] = $current;

        // remove $ClosedSet from $PointSet;

        $PointSet2 = stringArrayRemove($ClosedSet, $VtxSet); 
        int $PointSet2Size = `size $PointSet2`;
    
        // calculate brute force visability graph for the current point and get its neighbors

        int $NumPoints = `size $VtxSet`;


        /* ----- potential for improvements here, i.e. remove irrelevant points from PointSet2, e.g. only cylce trough points in a 'projection field' ----- */


        for ($i = 0; $i < $PointSet2Size; $i++) // worst case run time O((n-1)*E)
        {
            int $visGraphSize = 0;
            int $j = 0;
            int $intersect;
            int $intersection;

            // get mesh name and vertex indices

            $currentID = stringToStringArray($current, "_");
            $PointID = stringToStringArray($PointSet2[$i], "_");

            int $currentIDsize = `size $currentID`;

            // check if $current is origin

            if ($currentIDsize < 3) // if so, set values for smooth attribute check in next step
            {
                $currentIDsize = 3;
                $currentID[2] = "0";
            }
            
            // check if '$PointSet[$i]' is insertion

            int $PointIDsize = `size $PointID`;
            if ($PointIDsize < 3) // if so, set values for smooth attribute check in next step
            {
                $PointIDsize = 3;
                $PointID[2] = "0";
            }
            
            int $IDdiff = int($currentID[($currentIDsize-1)]) - int($PointID[($PointIDsize-1)]);

            // check if points are adjacent on the polygon, if so skip visability graph calculations

            if ($currentID[0] == $PointID[0] && $currentID[($currentIDsize-3)] == $PointID[($PointIDsize-3)] && $IDdiff == 1 || $currentID[0] == $PointID[0] && $currentID[($currentIDsize-3)] == $PointID[($PointIDsize-3)] && $IDdiff == -1)
            {
                $visGraphSize = `size $visGraph`;
                $visGraph[$visGraphSize] = $PointSet2[$i];  
            }
            else // calculate visibility graph: If line intersects any edge, then point $PointSet2[$i] will not be added to visibility graph; if line does not intersect any edges, then point $PointSet2[$i] will be added to visibility graph
            {
                // reduce $RefEdgeSet depending on source mesh of $current and $PointSet2[$i]

                if ($currentID[0] == $PointID[0] && $currentID[0] == $prox) // if both points are from the proximal mesh, discard edges from distal mesh
                {
                    $RefEdgeSet = $AllProxEdgeSet;
                    $RefCrossSet = $ProxEdgeCrossSet;
                }
                else if ($currentID[0] == $PointID[0] && $currentID[0] == $dist) // if both points are from the distal mesh, discard edges from proximal mesh
                {
                    $RefEdgeSet = $AllDistEdgeSet;
                    $RefCrossSet = $DistEdgeCrossSet;
                }
                else // points are from both proximal and distal meshes, need to check all edges
                {
                    $RefEdgeSet = $AllEdgeSet;
                    $RefCrossSet = $AllEdgeCrossSet;
                }

                // get size of $RefEdgeSet

                int $numEdges = `size $RefEdgeSet`;

                // get line defined by $current and $PointSet2[$i] to check against edges crossing polygons

                string $TempLine = $current + " " + $PointSet2[$i];
                string $TempLineReversed = $PointSet2[$i] + " " + $current;

                // cycle through points and check for intersections


                /* ----- potential for improvements here, instead of brute forcing visibility graph could implement faster method ----- */


                //============= calculate on-the-fly visibility graph for current point =============//

                while ($intersect == 0 && $j < $numEdges) // break loop as soon as an intersection is detected or all edges where checked
                {
                    tokenizeList($RefEdgeSet[$j], $TemporaryVtx);
                    $intersection = intersect($current,$PointSet2[$i],$TemporaryVtx[0],$TemporaryVtx[1]); // check if line p0p1 intersects line p2p3

                    // if lines are parallel check if they cross polygon, if they do skip line

                    if ($intersection < 0) // if line p0p1 is parallel to line p2p3, check if it crosses polygon
                    {
                        if ($TempLine == $RefEdgeSet[$j]) // check whether $TempLine is current edge
                        {
                            int $LineCrossPoly1 = stringArrayFind($TempLine, 0, $RefCrossSet);

                            if ($LineCrossPoly1 < 0) // $TempLine is not part of $CrossSet
                            {
                                $intersect += 0;
                            }
                            else // $TempLine is part of $CrossSet, i.e. line p0p1 crosses polygon
                            {
                                $intersect += 1;
                            }
                        }
                        else if ($TempLineReversed == $RefEdgeSet[$j]) // check whether $TempLineReversed is current edge
                        {
                            int $LineCrossPoly2 = stringArrayFind($TempLineReversed, 0, $RefCrossSet);

                            if ($LineCrossPoly2 < 0) // $TempLineReversed is not part of $CrossSet
                            {
                                $intersect += 0;
                            }
                            else // $TempLineReversed is part of $CrossSet, i.e. line p1p0 crosses polygon
                            {
                                $intersect += 1; 
                            } 
                        }
                        else // lines are parallel but not crossing polygon, i.e. line p0p1 is probably along polygon border
                        {
                            $intersect += 0;
                        }
                    }
                    else // sum $intersect up, if $intersect < 0, then p0p[$i] crosses edge[$j]
                    {
                        $intersect += $intersection;
                    }

                    $j += 1;
                }
                
                if ($intersect == 0) // if line p0p[$i] doesn't intersect any edges add $PointSet2[$i] to visGraph of p0 (i.e. $current)
                {
                    $visGraphSize = `size $visGraph`;
                    $visGraph[$visGraphSize] = $PointSet2[$i];
                }
            }
        }

        $visGraphSize = `size $visGraph`;


        /* ----- potential for improvements here, i.e. reduce visGraph before cycling through points ----- */


        // cylce through visible 'neighbors'

        for ($k = 0; $k < $visGraphSize; $k++)
        {
            string $Neighbor = $visGraph[$k];

            int $ClosedSetCheck = stringArrayContains($Neighbor,$ClosedSet); // check if $Neighbor is in $ClosedSet
            int $OpenSetCheck = stringArrayContains($Neighbor,$OpenSet); // check if $Neighbor is in $OpenSet

            if ($ClosedSetCheck != 1) // if it is not continue
            {
                vector $CurrentPos = `xform -q -t -ws $current`;
                vector $NeighborPos = `xform -q -t -ws $Neighbor`;
                vector $EndPos = `xform -q -t -ws $insertion`;

                float $distNeighbor = mag ($CurrentPos-$NeighborPos); // calculate distance between points for g value
                float $tempG = float(`getAttr ($current + ".rotateY")`) + $distNeighbor; // distance from start to neighbor through current

                if ($OpenSetCheck == 1) // if Neighbor is in OpenSet check g value
                {
                    $NeighborG = `getAttr ($Neighbor + ".rotateY")`;

                    if ($tempG < $NeighborG) // if tempG is lower than previous g value, set it to new g value
                    {
                        setAttr ($Neighbor + ".rotateY") $tempG;
                    }
                }
                else // if Neighbor is not in OpenSet add it and set g value
                {                   
                    setAttr ($Neighbor + ".rotateY") $tempG;
                    $OpenSetSize = `size $OpenSet`;
                    $OpenSet[$OpenSetSize] = $Neighbor;
                }

                // calculate h and f values

                float $NeighborH = mag ($NeighborPos-$EndPos); // calculate distance to end point for heuristic
                float $NeighborF = $NeighborH + float(`getAttr ($Neighbor + ".rotateY")`); 

                // set h and f values

                setAttr ($Neighbor + ".rotateX") $NeighborF;
                setAttr ($Neighbor + ".rotateZ") $NeighborH;

                $OpenSetSize = `size $OpenSet`;
            }
        }
    }

    float $PathLength[];
    $PathLength = {0.0,-1.0};

    // clean up

    delete $prox $dist $tempGRP;
    rename $nDistCopy $distal;
    rename $nProxCopy $proximal;
    
    setAttr ($origin + ".scale") 1 1 1;
    setAttr ($insertion + ".scale") 1 1 1;
    setAttr ($insertion + ".rotate") 0 0 0;

    // report ligament length

    return $PathLength;

};